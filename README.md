# aurkitu 

[![Build Status](https://travis-ci.org/mhradek/aurkitu.svg?branch=master)](https://travis-ci.org/mhradek/aurkitu)
[![codecov](https://codecov.io/gh/mhradek/aurkitu/branch/master/graph/badge.svg)](https://codecov.io/gh/mhradek/aurkitu)
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.michaelhradek/aurkitu-maven-plugin/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.michaelhradek/aurkitu-maven-plugin)


Aurkitu is the Basque word for for the English phrase "to find". This project is intended to assist in the automatic generation of FlatBuffer IDL/schemas from Java source. But isn't this backwards? Shouldn't the schema generate the models for both client and service? Unfortunately, when using models which are stored in cloud based storage mechanisms (e.g. AWS Dynamo DB) requires that table definitions, keys, and other attributes to be declared within the model. Hence with this project the aim is to allow the server implementation to remain as the master version of these models making the schema, flatbuffers, and client code as auxillery. 

* FlatBuffers: https://google.github.io/flatbuffers/
* Building schemas with Maven: https://github.com/davidmoten/flatbuffers

Aurkitu currently supports Flatbuffers version 1.3.

## please note 
This is a very early proof-of-concept currently being developed in spare time.

## roadmap
- [x] handle core types
- [ ] handle options, deprecation, and default values
- [ ] validate dependencies (optional)
- [x] implement as plugin and test against a sample project
- [ ] test with flatc
- [ ] update with current (1.8) feature support (i.e. gRPC, Field, String constant, etc.)
- [x] release to maven

## integration
Add the following to your dependencies within your `pom.xml`:
```
<dependency>
    <groupId>com.michaelhradek</groupId>
    <artifactId>aurkitu-maven-plugin</artifactId>
    <version>0.0.3</version>
</dependency>
```
Followed by the following to the `plugins` of your `build` specifications:
```
<plugin>
    <groupId>com.michaelhradek</groupId>
    <artifactId>aurkitu-maven-plugin</artifactId>
    <configuration>
        <schemaName>user</schemaName>
        <searchPath>com.company.package.subpackage.*</searchPath>
        <schemaNamespace>com.company.package.subpackage.flatbuffers</schemaNamespace>
        <schemaIncludes>
             <include>"../../../../target/maven-shared-archive-resources/flatbuffers/other.fbs"</include>
        </schemaIncludes>
        <validateSchema>true</validateSchema>
        <namespaceOverrideMap>
	          <com.company.package.search>com.company.package.replace</com.company.package.search>
        </namespaceOverrideMap>        
    </configuration>
    <executions>
        <execution>
            <phase>process-classes</phase>
            <goals>
                <goal>build-schema</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```
## usage
Through the use of annotations:
```
@FlatBufferTable
public class SampleClassReferenced {

    @FlatBufferFieldOptions(fieldType = FieldType.IDENT, useFullName = true)
    SampleClassReferenced fullnameClass;
    
    @FlatBufferFieldOptions(fieldType = FieldType.IDENT, defaultValue = "SHORT_SWORD")
    protected SampleClassTableInnerEnumInt innerEnum;
...
```
Specify a root type:
```
@FlatBufferTable(rootType = true)
public class SampleClassTable {
...
```
Specify different structure declarations:
```
@FlatBufferTable(TableStructureType.STRUCT)
public class SampleClassStruct {
...
}

@FlatBufferEnum(enumType = FieldType.BYTE)
public enum SampleEnumByte {

    // If you specify a enumType you will need to specify which field represents the type (as there can be several fields within an `ENUM`)
    @FlatBufferEnumTypeField
    byte id;
    
    String description;
    
    SampleEnumByte(byte id, String description) {
...
```

Ignore fields:
```
@FlatBufferIgnore
protected String ignore;
```

## sample output
This sample is generated by the JUnit tests within the project into a `test.fbs` file.

```
// Aurkitu automatically generated IDL FlatBuffer Schema
// @version: a1170911

enum SampleEnumNull { PlatformAlpha, PlatformBeta, PlatformGamma }

enum Matrix : int { SMALL = 10000, MEDIUM = 20000, LARGE = 30000 }

enum Factor : double { SMALL = 10000.0, MEDIUM = 20000.0, LARGE = 30000.0 }

enum SampleEnumByte : byte { EnvironmentAlpha = 1, EnvironmentBeta = 2, EnvironmentGamma = 3 }

enum Impulse : float { SMALL = 123.0, MEDIUM = 456.0, LARGE = 789.0 }

enum SplineEstimate : long { SMALL = 10000, MEDIUM = 20000, LARGE = 30000 }

enum VectorSize : short { SMALL = 10000, MEDIUM = 20000, LARGE = 30000 }

enum Option { FirstOption, SecondOption, ThirdOption }

enum SampleClassTableInnerEnumInt { DAGGER, SHORT_SWORD, SWORD, GREAT_SWORD }

table SampleClassNamespaceMap {
  id:string;
}

table SampleAnonymousEnum {
  option:Option;
  size:VectorSize;
  estimate:SplineEstimate;
  matrix:Matrix;
  impulse:Impulse;
  factor:Factor;
}

table SampleClassTableWithUndefined {
  id:long;
  message:string;
  awesomeUndefinedClass:SimpleUndefinedClass;
}

struct SampleClassStruct {
  x:float;
  y:float;
  z:float;
}

table SampleClassTable {
  id:long;
  name:string;
  level:short;
  currency:int;
  createTime:long;
  tokens:[string];
  deleted:bool;
  energy:byte;
  weight:double;
  options:[int];
  anomalousSamples:[SimpleUndefinedClass];
  definedInnerEnumArray:[com.michaelhradek.aurkitu.test.SampleClassReferenced$SampleClassTableInnerEnumInt];
  innerEnum:SampleClassTableInnerEnumInt = SHORT_SWORD;
  fullnameClass:com.michaelhradek.aurkitu.test.SampleClassReferenced;
}

table SampleClassReferenced {
  id:long;
  baggage:[SampleClassTable];
  samples:[com.michaelhradek.aurkitu.test.other.SampleClassNamespaceMap];
  abstractField:string;
}

table InnerClassStatic {
  virulant:bool;
}

table InnerClass {
  processed:bool;
  weaponType:SampleClassTableInnerEnumInt;
}

root_type: SampleClassTable;
```      
