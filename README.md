# aurkitu 

[![Build Status](https://travis-ci.org/mhradek/aurkitu.svg?branch=master)](https://travis-ci.org/mhradek/aurkitu)
[![codecov](https://codecov.io/gh/mhradek/aurkitu/branch/master/graph/badge.svg)](https://codecov.io/gh/mhradek/aurkitu)
[![Maven Central](https://maven-badges.herokuapp.com/maven-central/com.michaelhradek/aurkitu-maven-plugin/badge.svg)](https://maven-badges.herokuapp.com/maven-central/com.michaelhradek/aurkitu-maven-plugin)


Aurkitu is the Basque word for for the English phrase "to find". This project is intended to assist in the automatic generation of FlatBuffer IDL/schemas from Java source. But isn't this backwards? Shouldn't the schema generate the models for both client and service? Unfortunately, when using models which are stored in cloud based storage mechanisms (e.g. AWS Dynamo DB) requires that table definitions, keys, and other attributes to be declared within the model. Hence with this project the aim is to allow the server implementation to remain as the master version of these models making the schema, flatbuffers, and client code as auxillery. 

* FlatBuffers: https://google.github.io/flatbuffers/
* Building schemas with Maven: https://github.com/davidmoten/flatbuffers

Aurkitu currently supports Flatbuffers version 1.3.

## please note 
This is a very early proof-of-concept currently being developed in spare time.

## roadmap
- [x] handle core types
- [ ] handle options, deprecation, and default values
- [ ] validate dependencies (optional)
- [x] implement as plugin and test against a sample project
- [ ] test with flatc (started)
- [ ] update with current (1.8) feature support (i.e. gRPC, Field, String constant, etc.)
- [x] release to maven

## peculiarities
While flatbuffers support unsigned primatives (e.g. ubyte, ushort, etc.), Java does not technically support them (though you can use the wrapper types [e.g. `java.lang.Long`, etc.]) to [simulate this behavior](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html). Eventually we could map to the wrapper types when building the schema files. At this time all primatives and their corresponding wrappers are mapped as primatives.

Aurkitu supports `java.util.Map` by creating an autogenerated key-value type which is then used via list in the defining type. It is a work around and the parsers using generated flatbuffers will need to translate accordingly. The name format is `MapValueSet_<type>_<field>`. The server and client will need to implement custom code to translate back and forth between `Object{K, V}[]` and `Map<K, V>`.

## integration
Add the following to your dependencies within your `pom.xml`:
```
<dependency>
    <groupId>com.michaelhradek</groupId>
    <artifactId>aurkitu-annotations</artifactId>
    <version>0.0.4</version>
</dependency>
```
Followed by the following to the `plugins` of your `build` specifications within your `pom.xml`:
```
<plugin>
    <groupId>com.michaelhradek</groupId>
    <artifactId>aurkitu-maven-plugin</artifactId>
    <version>0.0.4</version>
    <configuration>
        <schemaName>user</schemaName>
        <searchPath>com.company.package.subpackage.*</searchPath>
        <schemaNamespace>com.company.package.subpackage.flatbuffers</schemaNamespace>
        <schemaIncludes>
             <include>"../../../../target/maven-shared-archive-resources/flatbuffers/other.fbs"</include>
        </schemaIncludes>
        <validateSchema>true</validateSchema>
        <namespaceOverrideMap>
	          <com.company.package.search>com.company.package.replace</com.company.package.search>
        </namespaceOverrideMap>        
    </configuration>
    <executions>
        <execution>
            <phase>process-classes</phase>
            <goals>
                <goal>build-schema</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```
## usage
Through the use of annotations:
```
@FlatBufferTable
public class SampleClassReferenced {

    @FlatBufferFieldOptions(fieldType = FieldType.IDENT, useFullName = true)
    SampleClassReferenced fullnameClass;
    
    @FlatBufferFieldOptions(fieldType = FieldType.IDENT, defaultValue = "SHORT_SWORD")
    protected SampleClassTableInnerEnumInt innerEnum;
...
```
Specify a root type:
```
@FlatBufferTable(rootType = true)
public class SampleClassTable {
...
```
Specify different structure declarations:
```
@FlatBufferTable(TableStructureType.STRUCT)
public class SampleClassStruct {
...
}

@FlatBufferEnum(enumType = FieldType.BYTE)
public enum SampleEnumByte {

    // If you specify a enumType you will need to specify which field represents the type (as there can be several fields within an `ENUM`)
    @FlatBufferEnumTypeField
    byte id;
    
    String description;
    
    SampleEnumByte(byte id, String description) {
...
```

Ignore fields:
```
@FlatBufferIgnore
protected String ignore;
```

## sample output
This sample is generated by the JUnit tests within the project into a `test.fbs` file.

```
// Aurkitu automatically generated IDL FlatBuffer Schema
// @version: c4f82c4d

// This is a enum comment
enum VectorSize : short { SMALL = 10000, MEDIUM = 20000, LARGE = 30000 }

enum SampleEnumNull : byte { PlatformAlpha, PlatformBeta, PlatformGamma }

enum Matrix : int { SMALL = 10000, MEDIUM = 20000, LARGE = 30000 }

enum SplineEstimate : long { SMALL = 10000, MEDIUM = 20000, LARGE = 30000 }

enum Option { FirstOption, SecondOption, ThirdOption }

enum SampleClassTableInnerEnumInt { DAGGER, SHORT_SWORD, SWORD, GREAT_SWORD }

enum SampleEnumByte : byte { EnvironmentAlpha = 1, EnvironmentBeta = 2, EnvironmentGamma = 3 }

struct SampleClassStruct {
  x:float;
  y:float;
  z:float;
}

// Auto-generated type for use with Map<?, ?>
table MapValueSet_SampleClassTable_dataMap {
  key:string;
  value:string;
}

// This is a type level comment
table SampleClassTable {
  id:long;
  name:string;
  level:short;	// This is a field level comment
  currency:int;
  createTime:long;
  tokens:[string];
  deleted:bool;
  energy:byte;
  weight:double;
  options:[int];
  anomalousSamples:[SimpleUndefinedClass];
  dataMap:[MapValueSet_SampleClassTable_dataMap];
  definedInnerEnumArray:[com.michaelhradek.aurkitu.test.SampleClassReferenced$SampleClassTableInnerEnumInt];
  innerEnum:SampleClassTableInnerEnumInt = SHORT_SWORD;
  fullnameClass:com.michaelhradek.aurkitu.test.SampleClassReferenced;
}

table SampleAnonymousEnum {
  option:Option;
  size:VectorSize;
  estimate:SplineEstimate;
  matrix:Matrix = SMALL;
}

table SampleClassTableWithUndefined {
  id:long;
  message:string;
  awesomeUndefinedClass:SimpleUndefinedClass;
}

table SampleClassReferenced {
  id:long;
  baggage:[SampleClassTable];
  samples:[com.michaelhradek.aurkitu.test.other.SampleClassNamespaceMap];
  abstractField:string;
}

table InnerClassStatic {
  virulant:bool;
}

table InnerClass {
  processed:bool;
  weaponType:SampleClassTableInnerEnumInt;
}

table SampleClassNamespaceMap {
  id:string;
}

root_type SampleClassTable;

// Schema failed validation (i.e. flatc will likely fail): 
// Issue : TYPE_DEFINITION_NOT_DEFINED, Location: SampleClassTable, Name: anomalousSamples
// Issue : INVALID_PATH, Location: SampleClassTable, Name: definedInnerEnumArray, Comment: Array type name contains '$'; using '@FlatBufferOptions(useFullName = true)' on inner not recommended: com.michaelhradek.aurkitu.test.SampleClassReferenced$SampleClassTableInnerEnumInt
// Issue : TYPE_DEFINITION_NOT_DEFINED, Location: SampleClassTableWithUndefined, Name: awesomeUndefinedClass
// Issue : MISCONFIGURED_DEFINITION, Location: Option, Name: null
// Issue : MISCONFIGURED_DEFINITION, Location: SampleClassTableInnerEnumInt, Name: null
```      
With schema validation enabled, comments will be added to the end of the generated schema file which should assist in the resolution of issues which may likely cause `flatc` to fail.